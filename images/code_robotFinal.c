#pragma config(Sensor, S1,     gyro,           sensorEV3_Gyro)
#pragma config(Sensor, S2,     colorD,         sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S3,     capteurDistance, sensorEV3_Ultrasonic)
#pragma config(Sensor, S4,     colorG,         sensorEV3_Color, modeEV3Color_Color)
#pragma config(Motor,  motorA,          moteurGauche,  tmotorEV3_Large, PIDControl, reversed, driveRight, encoder)
#pragma config(Motor,  motorB,          moteurDroit,   tmotorEV3_Large, PIDControl, reversed, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

string test;
void avance80 (void);
void tourneD (void);
void tourneG (void);
void tourneBD (void);
void tourneBG (void);
void arret (void);
bool isRouge (void);
bool isWhiteG (void);
bool isWhiteD (void);
bool isBlackG (void);
bool isBlackD (void);
void evite_obstacle(void);
void ligne(void);

task main()
{
	int marche=0;
	int tour=0;
	int tempsArrive;
	bool flagR=false;
	eraseDisplay();



	while(marche==0){
		ligne();
	if(getUSDistance(S3)<25){evite_obstacle();}		//evitement obstacle

		if (time1(T2)>2000)flagR=false;				//détection des tours
		if(isRouge()&&(flagR==false))
			{
			tour+=1;
			clearTimer(T2);
			flagR=true;

			if (tour==1)
				{
				clearTimer(T1);
			}
			if(tour==3)
				{
			marche=1;
			arret();
			tempsArrive=time1(T1)/1000;
			while(1){displayTextLine(8,"temps de courses: %i",tempsArrive);}
			}
		}
	}
}

void avance80(void)
{
	motor(moteurGauche)=50;
	motor(moteurDroit)=50;
}

void tourneD(void)
{
	motor(moteurGauche)=40;
	motor(moteurDroit)=-40;
	delay(100);
}
void tourneG(void)
{
	motor(moteurGauche)=-40;
	motor(moteurDroit)=40;
	delay(100);
}
void tourneBD(void)
{
	motor(moteurGauche)=127;
	motor(moteurDroit)=-127;
}
void tourneBG(void)
{
	motor(moteurGauche)=-127;
	motor(moteurDroit)=127;
}
void arret(void)
{
	motor(moteurGauche)=0;
	motor(moteurDroit)=0;
}

bool isRouge (void)
{
	int colorRd;
	int colorRg;
	colorRg=getColorName(S4);
	colorRd=getColorName(S2);
	if ((colorRg==(int)colorRed)||(colorRd==(int)colorRed)){return true;}
	else return false;
}
bool isWhiteD (void)
{
	int colorWd;
	colorWd=getColorName(S2);
	if (colorWd==(int)colorWhite){return true;}
	else return false;
}
bool isWhiteG (void)
{
	int colorWg;
	colorWg=getColorName(S4);
	if (colorWg==(int)colorWhite){return true;}
	else return false;
}

bool isBlackD (void)
{
	int colorBd;
	colorBd=getColorName(S2);
	if (colorBd==(int)colorBlack){return true;}
	else return false;
}
bool isBlackG (void)
{
	int colorBg;
	colorBg=getColorName(S4);
	if (colorBg==(int)colorBlack){return true;}
	else return false;
}

void evite_obstacle(void)
{
	motor(moteurGauche)=50;
	motor(moteurDroit)=-30;
	delay(500);
	motor(moteurGauche)=60;
	motor(moteurDroit)=60;
	delay(800);
	motor(moteurGauche)=-30;
	motor(moteurDroit)=60;
	delay(500);
	motor(moteurGauche)=60;
	motor(moteurDroit)=60;
	delay(800);
	motor(moteurGauche)=-60;
	motor(moteurDroit)=70;
	delay(500);
	motor(moteurGauche)=60;
	motor(moteurDroit)=60;
	delay(200);
	while(!isBlackD()){
	motor(moteurGauche)=40;
	motor(moteurDroit)=40;
	}
}

void ligne(void){

	if(isWhiteD() && isWhiteG()){
		avance80();
		}
		while(isBlackD()){
		tourneBD();
		delay(200);
	}
	while(isBlackG()){
		tourneBG();
		delay(200);
		}
}
